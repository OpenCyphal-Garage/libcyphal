/*
 * UAVCAN marshalling functions for libnanocan.
 *
 * Autogenerated, do not edit.
 *
 * Source file: ${t.source_file}
 */

#pragma once

#include <stdint.h>

% for inc in t.c_includes:
#include <${inc}>
% endfor

/******************************* Source text **********************************
% for line in t.source_text.strip().splitlines():
${line}
% endfor
******************************************************************************/

/********************* DSDL signature source definition ***********************
% for line in t.get_dsdl_signature_source_definition().splitlines():
${line}
% endfor
******************************************************************************/

#ifndef UAVCAN_PACK_STRUCTS
# error UAVCAN_PACK_STRUCTS
#endif

#if UAVCAN_PACK_STRUCTS
UAVCAN_PACKED_BEGIN
#endif

% for inc in t.c_includes:
#include <${inc}>
% endfor

#define ID_TYPE_${t.short_name}    ${t.default_dtid}

% if t.kind == t.KIND_SERVICE:
% else:
    %if len(t.constants) > 0:
        <!--(macro generate_primary_body)--> #! type_name, max_bitlen, fields, constants

            <!--(macro expand_attr_types)--> #! group_name, attrs
                % for idx,a in enumerate(attrs):
#define ${a.name} ${a.c_value}
                % endfor
            <!--(end)-->

            ${expand_attr_types(group_name='Constants_t', attrs=constants)}
        <!--(end)-->

    ${generate_primary_body(type_name=t.c_type_name, max_bitlen=t.get_max_bitlen(), fields=t.fields, constants=t.constants)}
    % endif
% endif

% if t.kind == t.KIND_SERVICE:
% else:

    <!--(macro generate_primary_body)--> #! type_name, max_bitlen, fields, constants
        <!--(macro expand_attr_types)--> #! group_name, attrs
            % for idx,a in enumerate(attrs):
                %if a.type.category == t.CATEGORY_ARRAY:
${a.type.bit_struct}
                %endif
            % endfor
        <!--(end)-->

        ${expand_attr_types(group_name='Constants_t', attrs=fields)}
    <!--(end)-->
    ${generate_primary_body(type_name=t.c_type_name, max_bitlen=t.get_max_bitlen(), fields=t.fields, constants=t.constants)}

% endif

typedef struct UAVCAN_EXPORT 
{
<!--(macro generate_primary_body)--> #! type_name, max_bitlen, fields, constants
    <!--(macro expand_attr_types)--> #! group_name, attrs
        % for a in attrs:
            % if a.type.category == a.type.CATEGORY_PRIMITIVE and a.type.kind == a.type.KIND_FLOAT:
    ${a.c_type} ${a.name};
            % endif
            % if a.type.category == a.type.CATEGORY_PRIMITIVE and a.type.kind != a.type.KIND_FLOAT:
    ${a.c_type} ${a.name}: ${a.type.bitlen};
            % endif
            % if a.type.category == a.type.CATEGORY_ARRAY
    ${a.c_type};
            % endif
        % endfor
    <!--(end)-->
    ${expand_attr_types(group_name='Fields', attrs=fields)}
<!--(end)-->
% if t.kind == t.KIND_SERVICE:
% else:
    ${generate_primary_body(type_name=t.c_type_name, max_bitlen=t.get_max_bitlen(), fields=t.fields, constants=t.constants)}
% endif
} ${t.c_function_name}_t;

uint8_t unmarshal_${t.c_function_name}( uint32_t can_id, uint32_t dh, uint32_t dl, ${t.c_function_name}_t *result )
{
    return is_last_frame( can_id );
}

void marshal_${t.c_function_name}( uint8_t *payload, uint8_t payload_len, uint32_t *dh, uint32_t *dl )
{

}

