<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>libuavcan: libuavcan::media::InterfaceGroup&lt; FrameT, MaxTxFrames, MaxRxFrames &gt; Class Template Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand" href="https://uavcan.org"><img src="uavcan_logo.svg" style="float:left;height:1.5em;padding:0em .5em .25em 0em;"/> libuavcan</a>
                    <em><a class="navbar-brand" href="https://buildkite.com/uavcan/libuavcan-v1/builds/1" style="font-size: .75em; color: coral">build:1</a></em>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibuavcan.html">libuavcan</a></li><li class="navelem"><b>media</b></li><li class="navelem"><a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html">InterfaceGroup</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">libuavcan::media::InterfaceGroup&lt; FrameT, MaxTxFrames, MaxRxFrames &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="interfaces_8hpp_source.html">libuavcan/media/interfaces.hpp</a>&quot;</code></p>
<div class="dynheader">
Collaboration diagram for libuavcan::media::InterfaceGroup&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlibuavcan_1_1media_1_1_interface_group__coll__graph.png" border="0" usemap="#libuavcan_1_1media_1_1_interface_group_3_01_frame_t_00_01_max_tx_frames_00_01_max_rx_frames_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="libuavcan_1_1media_1_1_interface_group_3_01_frame_t_00_01_max_tx_frames_00_01_max_rx_frames_01_4_coll__map" id="libuavcan_1_1media_1_1_interface_group_3_01_frame_t_00_01_max_tx_frames_00_01_max_rx_frames_01_4_coll__map">
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5a121830b8c75c5a56aa899ccc452e61"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#a5a121830b8c75c5a56aa899ccc452e61">FrameType</a> = FrameT</td></tr>
<tr class="separator:a5a121830b8c75c5a56aa899ccc452e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:accac774c75dff77de458bf33d326ab9b"><td class="memItemLeft" align="right" valign="top">virtual std::uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#accac774c75dff77de458bf33d326ab9b">getInterfaceCount</a> () const =0</td></tr>
<tr class="separator:accac774c75dff77de458bf33d326ab9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38dbd59fe9c3309cc902ef9d7d0fca4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbd">libuavcan::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#af38dbd59fe9c3309cc902ef9d7d0fca4">write</a> (std::uint_fast8_t interface_index, const FrameT(&amp;frames)[MaxTxFrames], std::size_t frames_len, std::size_t &amp;out_frames_written)=0</td></tr>
<tr class="separator:af38dbd59fe9c3309cc902ef9d7d0fca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8083e54bb47f0690016e4f3a747a93fb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbd">libuavcan::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#a8083e54bb47f0690016e4f3a747a93fb">read</a> (std::uint_fast8_t interface_index, FrameT(&amp;out_frames)[MaxRxFrames], std::size_t &amp;out_frames_read)=0</td></tr>
<tr class="separator:a8083e54bb47f0690016e4f3a747a93fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45e1757e56de6e4ca38e148e734b899e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbd">libuavcan::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#a45e1757e56de6e4ca38e148e734b899e">reconfigureFilters</a> (const typename FrameType::Filter *filter_config, std::size_t filter_config_length)=0</td></tr>
<tr class="separator:a45e1757e56de6e4ca38e148e734b899e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20a55316dd91032308b84f8ce0c4ac4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbd">libuavcan::Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#ab20a55316dd91032308b84f8ce0c4ac4">select</a> (<a class="el" href="classlibuavcan_1_1duration_1_1_monotonic.html">libuavcan::duration::Monotonic</a> timeout, bool ignore_write_available)=0</td></tr>
<tr class="separator:ab20a55316dd91032308b84f8ce0c4ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a723a5d82a186e0276c4b28fce074182d"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#a723a5d82a186e0276c4b28fce074182d">RxFramesLen</a> = MaxRxFrames</td></tr>
<tr class="separator:a723a5d82a186e0276c4b28fce074182d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd6445c5b6a6d7e83b383ebcd12697c"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#a4fd6445c5b6a6d7e83b383ebcd12697c">TxFramesLen</a> = MaxTxFrames</td></tr>
<tr class="separator:a4fd6445c5b6a6d7e83b383ebcd12697c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename FrameT, std::size_t MaxTxFrames = 1, std::size_t MaxRxFrames = 1&gt;<br />
class libuavcan::media::InterfaceGroup&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;</h3>

<p>Non-blocking connection to a UAVCAN bus with isolated rx and tx queues. While libuavcan may share hardware peripherals with other components and/or processes for a given system a media layer interface group object shall be the sole access to hardware connections to a bus for this library.</p>
<p>When a group has more than one interface the group shall be managed as a set of redundant connections to a single, physical bus. Libuavcan shall use the first N interfaces it is capable of useing for redundancy. It may not use all available intefaces where the group is larger than the library's built-in support for a fixed number of redundant channels. Because of this, media layer implementations should use constants in higher layers to determine the optimal number of interfaces to provide to interface groups. Because this is also a hardware constraint system designers should consider the trade off in redundancy, complexity, and memory resources that are affected by the number of redundant interfaces in each group. See the <a class="el" href="_transport_guide.html">Libuavcan Guide to the Transport Layer</a> for full documentation.</p>
<p>MaxTxFrames and MaxRxFrames are template parameters to allow an implementation to allocate adequate buffers as part of their type. As such, these values may affect the amount of heap, bss, or stack RAM used depending on where the media layer objects are placed for a given system or if an implementation chooses to use dynamic memory internally. Media layer implementations should document this and all other parameters that affect the amount and type of memory used for a particular system and provide guidance for tuning performance versus memory size to the user.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">FrameT</td><td>The media-specific frame type to be exchanged across this interface. </td></tr>
    <tr><td class="paramname">MaxTxFrames</td><td>The maximum number of frames that can be written in a single operation using this interface. This value must be &gt; 0. If set to 1 then specializations may use different system APIs than if set to &gt; 1. </td></tr>
    <tr><td class="paramname">MaxRxFrames</td><td>The maximum number of frames that can be read in a single operation using this interface. This value must be &gt; 0. If set to 1 then specializations may use different system APIs then if set to &gt; 1. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5a121830b8c75c5a56aa899ccc452e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a121830b8c75c5a56aa899ccc452e61">&#9670;&nbsp;</a></span>FrameType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FrameT, std::size_t MaxTxFrames = 1, std::size_t MaxRxFrames = 1&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html">libuavcan::media::InterfaceGroup</a>&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;::<a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#a5a121830b8c75c5a56aa899ccc452e61">FrameType</a> =  FrameT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The media-specific frame type exchanged across this interface. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="accac774c75dff77de458bf33d326ab9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accac774c75dff77de458bf33d326ab9b">&#9670;&nbsp;</a></span>getInterfaceCount()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FrameT, std::size_t MaxTxFrames = 1, std::size_t MaxRxFrames = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::uint_fast8_t <a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html">libuavcan::media::InterfaceGroup</a>&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;::getInterfaceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of interfaces in this group. Valid indicies where used as an input argument are [0..<a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html#accac774c75dff77de458bf33d326ab9b">getInterfaceCount()</a>). </p><dl class="section return"><dt>Returns</dt><dd>1-* representing the number of interfaces in this group. If 0 is returned then the object itself is invalid and the library entered undefined behaviour sometime before or while this method was called. </dd></dl>

</div>
</div>
<a id="a8083e54bb47f0690016e4f3a747a93fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8083e54bb47f0690016e4f3a747a93fb">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FrameT, std::size_t MaxTxFrames = 1, std::size_t MaxRxFrames = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbd">libuavcan::Result</a> <a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html">libuavcan::media::InterfaceGroup</a>&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;::read </td>
          <td>(</td>
          <td class="paramtype">std::uint_fast8_t&#160;</td>
          <td class="paramname"><em>interface_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FrameT(&amp;)&#160;</td>
          <td class="paramname"><em>out_frames</em>[MaxRxFrames], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>out_frames_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-blocking reception.</p>
<p>Timestamps should be provided by the media driver, ideally by the hardware peripheral.</p>
<p>While the monotonic timestamp is required the UAVCAN protocol can tolerate imprecision since these timestamps are used only for protocol timing validation (i.e. transfer timeouts and inter-transfer intervals).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_index</td><td>The index of the interface in the group to read the frames from. </td></tr>
    <tr><td class="paramname">out_frames</td><td>A buffer of frames to read. </td></tr>
    <tr><td class="paramname">out_frames_read</td><td>On output the number of frames read into the out_frames array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbda505a83f220c02df2f85c3810cd9ceb38">libuavcan::Result::Success</a> If no errors occurred. </dd></dl>

</div>
</div>
<a id="a45e1757e56de6e4ca38e148e734b899e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e1757e56de6e4ca38e148e734b899e">&#9670;&nbsp;</a></span>reconfigureFilters()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FrameT, std::size_t MaxTxFrames = 1, std::size_t MaxRxFrames = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbd">libuavcan::Result</a> <a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html">libuavcan::media::InterfaceGroup</a>&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;::reconfigureFilters </td>
          <td>(</td>
          <td class="paramtype">const typename FrameType::Filter *&#160;</td>
          <td class="paramname"><em>filter_config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>filter_config_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reconfigure the filters for all interfaces in the group. This is an optional method that is only required if applications wish to dynamically subscribe and unsubscribe to messages after the media layer has been initialized. For less dynamic applications this method can simply return <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbda997ca4ce119685f40f03a9a8a6c5346e">libuavcan::Result::NotImplemented</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filter_config</td><td>The filtering to apply equally to all members of the group. </td></tr>
    <tr><td class="paramname">filter_config_length</td><td>The length of the <code>filter_config</code> argument. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbda505a83f220c02df2f85c3810cd9ceb38">libuavcan::Result::Success</a> if the group's receive filtering was successfully reconfigured. <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbda997ca4ce119685f40f03a9a8a6c5346e">libuavcan::Result::NotImplemented</a> if this media layer implementation does not support dynamic filter reconfiguration. Errors shall be returned if one or more interfaces in this group are not configured since this will leave the group in an unspecified state. </dd></dl>

</div>
</div>
<a id="ab20a55316dd91032308b84f8ce0c4ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20a55316dd91032308b84f8ce0c4ac4">&#9670;&nbsp;</a></span>select()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FrameT, std::size_t MaxTxFrames = 1, std::size_t MaxRxFrames = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbd">libuavcan::Result</a> <a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html">libuavcan::media::InterfaceGroup</a>&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;::select </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibuavcan_1_1duration_1_1_monotonic.html">libuavcan::duration::Monotonic</a>&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignore_write_available</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Block for a specified amount of time or until any interface in the group becomes ready to read or write.</p>
<p>Note that this method may return even if no requested events actually occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>The amount of time to wait for an event. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ignore_write_available</td><td>If true then this method will not return if interfaces become available only for write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbda2b7ebb9a4b6667e014f9b7cd8d49fbc7">libuavcan::Result::SuccessTimeout</a> if no events ocurred but the select operation timedout. <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbda505a83f220c02df2f85c3810cd9ceb38">libuavcan::Result::Success</a> if one or more of the provided interfaces are ready for read, and if <code>ignore_write_available</code> is false, or write. <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbdac8b8689d3e92659667d6558bafc569cf">libuavcan::Result::SuccessPartial</a> if one or more errors were reported for one or more interfaces. </dd></dl>

</div>
</div>
<a id="af38dbd59fe9c3309cc902ef9d7d0fca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38dbd59fe9c3309cc902ef9d7d0fca4">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FrameT, std::size_t MaxTxFrames = 1, std::size_t MaxRxFrames = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbd">libuavcan::Result</a> <a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html">libuavcan::media::InterfaceGroup</a>&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::uint_fast8_t&#160;</td>
          <td class="paramname"><em>interface_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FrameT(&amp;)&#160;</td>
          <td class="paramname"><em>frames</em>[MaxTxFrames], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>frames_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t &amp;&#160;</td>
          <td class="paramname"><em>out_frames_written</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-blocking transmission. All implementations will have some intermediate buffer this method writes to since it does not block on actual transmission of the frame. For some implementations, this method may borrow CPU time to move another, higher priority frame into a lower-level queue after enqueueing the given one in an intermediate queue.</p>
<p>This inteface does not provide a "write to all interfaces in group" because of the complexity in handling partial failures. Higher layers must handle the logic of dispatching messages accross redundant interfaces in groups and handle individual interface failures appropriately.</p>
<dl class="section note"><dt>Note</dt><dd>Implementations are allowed to provide queues based on message priority. Because of this, if a given message cannot be written the media layer should keep trying to write other messages with a different priority.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interface_index</td><td>The index of the interface in the group to write the frames to. </td></tr>
    <tr><td class="paramname">frames</td><td>1..* frames to write into the system queues for immediate transmission. </td></tr>
    <tr><td class="paramname">frames_len</td><td>The number of frames in the frames array that should be sent (starting from frame 0). </td></tr>
    <tr><td class="paramname">out_frames_written</td><td>The number of frames written. If this is less than frames_len then frames [0 - out_frames_written) were enqueued for transmission. Frames [out_frames_written - frames_len) were not able to be sent. Nominally this is due to the internal queues being full. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbdac8b8689d3e92659667d6558bafc569cf">libuavcan::Result::SuccessPartial</a> if some but not all of the frames were written. <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbda1a22c40923d2978b2a258720df650702">libuavcan::Result::BufferFull</a> if no frames could be written because the buffer was full. <a class="el" href="namespacelibuavcan.html#acec218dc94b3c1d8e218122515f49bbda505a83f220c02df2f85c3810cd9ceb38">libuavcan::Result::Success</a> if all frames were written. </dd></dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a723a5d82a186e0276c4b28fce074182d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723a5d82a186e0276c4b28fce074182d">&#9670;&nbsp;</a></span>RxFramesLen</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FrameT, std::size_t MaxTxFrames = 1, std::size_t MaxRxFrames = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html">libuavcan::media::InterfaceGroup</a>&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;::RxFramesLen = MaxRxFrames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The length of arrays used to read frames through this interface. </p>

</div>
</div>
<a id="a4fd6445c5b6a6d7e83b383ebcd12697c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd6445c5b6a6d7e83b383ebcd12697c">&#9670;&nbsp;</a></span>TxFramesLen</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FrameT, std::size_t MaxTxFrames = 1, std::size_t MaxRxFrames = 1&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::size_t <a class="el" href="classlibuavcan_1_1media_1_1_interface_group.html">libuavcan::media::InterfaceGroup</a>&lt; FrameT, MaxTxFrames, MaxRxFrames &gt;::TxFramesLen = MaxTxFrames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The length of arrays used to read frames from this interface. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>libuavcan/include/libuavcan/media/<a class="el" href="interfaces_8hpp_source.html">interfaces.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<address class="footer-copyright"><small>
  <a href="https://uavcan.org">UAVCAN</a>
  – Copyright (C) 2014-1029 Pavel Kirienko <pavel.kirienko@gmail.com>
  – Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved
  – This documentation is provided under the MIT licence as part of the <a href="https://github.com/UAVCAN/libuavcan/blob/master/LICENSE">libuavcan project</a>.
  </small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
