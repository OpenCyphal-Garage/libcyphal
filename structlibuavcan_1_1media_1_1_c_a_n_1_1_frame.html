<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <!-- For Mobile Devices -->
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
        <meta name="generator" content="Doxygen 1.8.13"/>
        <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
        <title>libuavcan: libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt; Struct Template Reference</title>
        <!--<link href="tabs.css" rel="stylesheet" type="text/css"/>-->
        <script type="text/javascript" src="dynsections.js"></script>
        <link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
        <link href="customdoxygen.css" rel="stylesheet" type="text/css" />
        <link href='https://fonts.googleapis.com/css?family=Roboto+Slab' rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
        <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <link href="jquery.smartmenus.bootstrap.css" rel="stylesheet">
        <script type="text/javascript" src="jquery.smartmenus.js"></script>
        <!-- SmartMenus jQuery Bootstrap Addon -->
        <script type="text/javascript" src="jquery.smartmenus.bootstrap.js"></script>
        <!-- SmartMenus jQuery plugin -->
    </head>
    <body>
        <nav class="navbar navbar-default" role="navigation">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand" href="https://uavcan.org"><img src="uavcan_logo.svg" style="float:left;height:1.5em;padding:0em .5em .25em 0em;"/> libuavcan</a>
                    <em><a class="navbar-brand" href="https://buildkite.com/uavcan/libuavcan-v1/builds/225" style="font-size: .75em; color: coral">build:225</a></em>
                </div>
            </div>
        </nav>
        <div id="top"><!-- do not remove this div, it is closed by doxygen! -->
            <div class="content" id="content">
                <div class="container">
                    <div class="row">
                        <div class="col-sm-12 panel " style="padding-bottom: 15px;">
                            <div style="margin-bottom: 15px;">
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibuavcan.html">libuavcan</a></li><li class="navelem"><b>media</b></li><li class="navelem"><b>CAN</b></li><li class="navelem"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<div class="title">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &quot;<a class="el" href="can_8hpp_source.html">libuavcan/media/can.hpp</a>&quot;</code></p>
<div class="dynheader">
Collaboration diagram for libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame__coll__graph.png" border="0" usemap="#libuavcan_1_1media_1_1_c_a_n_1_1_frame_3_01_m_t_u_bytes_param_00_01_flag_bits_compare_mask_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="libuavcan_1_1media_1_1_c_a_n_1_1_frame_3_01_m_t_u_bytes_param_00_01_flag_bits_compare_mask_01_4_coll__map" id="libuavcan_1_1media_1_1_c_a_n_1_1_frame_3_01_m_t_u_bytes_param_00_01_flag_bits_compare_mask_01_4_coll__map">
<area shape="rect" id="node2" href="classlibuavcan_1_1time_1_1_monotonic.html" title="{libuavcan::time::Monotonic\n||}" alt="" coords="5,859,204,936"/>
<area shape="rect" id="node3" href="classlibuavcan_1_1time_1_1_base.html" title="{libuavcan::time::Base\l\&lt; Monotonic, duration\l::Monotonic \&gt;\n||+ toMicrosecond()\l+ operator=()\l+ operator=()\l+ operator==()\l+ operator!=()\l+ operator\&lt;()\l+ operator\&gt;()\l+ operator\&lt;=()\l+ operator\&gt;=()\l+ operator+()\l+ operator&#45;()\l+ operator+=()\l+ operator&#45;=()\l+ getMaximum()\l+ fromMicrosecond()\l# ~Base()\l# Base()\l# Base()\l# Base()\l}" alt="" coords="21,439,188,809"/>
<area shape="rect" id="node4" href="classlibuavcan_1_1time_1_1_base.html" title="{libuavcan::time::Base\l\&lt; Type, DType, USecT \&gt;\n||+ toMicrosecond()\l+ operator=()\l+ operator=()\l+ operator==()\l+ operator!=()\l+ operator\&lt;()\l+ operator\&gt;()\l+ operator\&lt;=()\l+ operator\&gt;=()\l+ operator+()\l+ operator&#45;()\l+ operator+=()\l+ operator&#45;=()\l+ getMaximum()\l+ fromMicrosecond()\l# ~Base()\l# Base()\l# Base()\l# Base()\l}" alt="" coords="15,5,194,361"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_1_1_filter.html">Filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8ba1832b4f51d0baf43924c5629d635a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a8ba1832b4f51d0baf43924c5629d635a">Frame</a> (const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> &amp;rhs)</td></tr>
<tr class="separator:a8ba1832b4f51d0baf43924c5629d635a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2358b525d70f979b3f1adc9f2646ae1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a2358b525d70f979b3f1adc9f2646ae1e">Frame</a> (std::uint32_t can_id, const std::uint8_t *can_data, <a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a> in_dlc, <a class="el" href="classlibuavcan_1_1time_1_1_monotonic.html">libuavcan::time::Monotonic</a> can_timestamp)</td></tr>
<tr class="separator:a2358b525d70f979b3f1adc9f2646ae1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935f666c376898fee73c0732bd9ca08c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a935f666c376898fee73c0732bd9ca08c">Frame</a> (std::uint32_t can_id, const std::uint8_t *can_data, <a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a> in_dlc)</td></tr>
<tr class="separator:a935f666c376898fee73c0732bd9ca08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5eade23c4b714ada7510a1170f73261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#ad5eade23c4b714ada7510a1170f73261">getDLC</a> () const</td></tr>
<tr class="separator:ad5eade23c4b714ada7510a1170f73261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a80e74e1b1dd8d6d1877dd7b09ac59a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a6a80e74e1b1dd8d6d1877dd7b09ac59a">setDataLength</a> (std::uint_fast8_t data_length)</td></tr>
<tr class="separator:a6a80e74e1b1dd8d6d1877dd7b09ac59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd1bb5849b58b8510d05a3d0756db392"><td class="memItemLeft" align="right" valign="top">std::uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#afd1bb5849b58b8510d05a3d0756db392">getDataLength</a> () const</td></tr>
<tr class="separator:afd1bb5849b58b8510d05a3d0756db392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695aff92f84e1e513deae2d7c0d6cfb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a695aff92f84e1e513deae2d7c0d6cfb2">operator!=</a> (const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> &amp;rhs) const</td></tr>
<tr class="separator:a695aff92f84e1e513deae2d7c0d6cfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923a7e4e9cc03d737dd71258928e6cfb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a923a7e4e9cc03d737dd71258928e6cfb">operator==</a> (const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> &amp;rhs) const</td></tr>
<tr class="separator:a923a7e4e9cc03d737dd71258928e6cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a9aa982a961cea7e930d74f8a69a85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a53a9aa982a961cea7e930d74f8a69a85">operator&lt;</a> (const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> &amp;other) const</td></tr>
<tr class="separator:a53a9aa982a961cea7e930d74f8a69a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9d956ffede16256c9f584f46f137bce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#af9d956ffede16256c9f584f46f137bce">operator&gt;</a> (const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> &amp;other) const</td></tr>
<tr class="separator:af9d956ffede16256c9f584f46f137bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabce585db499eb1d688e3052b86b5530"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#aabce585db499eb1d688e3052b86b5530">operator=</a> (const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> &amp;rhs)</td></tr>
<tr class="separator:aabce585db499eb1d688e3052b86b5530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ae0b9d24e022c4d942f874f92cbc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a7f1ae0b9d24e022c4d942f874f92cbc7">priorityHigherThan</a> (const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> &amp;rhs) const</td></tr>
<tr class="separator:a7f1ae0b9d24e022c4d942f874f92cbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa7dcd1768a8494c085f70009c234f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a2fa7dcd1768a8494c085f70009c234f4">priorityLowerThan</a> (const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> &amp;rhs) const</td></tr>
<tr class="separator:a2fa7dcd1768a8494c085f70009c234f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a719c9c9fbb3c473108cfc7fa12c6c856"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a719c9c9fbb3c473108cfc7fa12c6c856">lengthToDlc</a> (std::uint_fast8_t length)</td></tr>
<tr class="separator:a719c9c9fbb3c473108cfc7fa12c6c856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf1613d2807c86ec495b30851a4eb429"><td class="memItemLeft" align="right" valign="top">static std::uint_fast8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#aaf1613d2807c86ec495b30851a4eb429">dlcToLength</a> (<a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a> dlc)</td></tr>
<tr class="separator:aaf1613d2807c86ec495b30851a4eb429"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a81731e84998bac95bd01ccc5ea06d3f8"><td class="memItemLeft" align="right" valign="top">std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a81731e84998bac95bd01ccc5ea06d3f8">id</a></td></tr>
<tr class="separator:a81731e84998bac95bd01ccc5ea06d3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf6cc91db672202e497c7de8a3bda07"><td class="memItemLeft" align="right" valign="top">std::uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a9cf6cc91db672202e497c7de8a3bda07">data</a> [MTUBytesParam]</td></tr>
<tr class="separator:a9cf6cc91db672202e497c7de8a3bda07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5d3279f4c8cf64eaf0b6a9a704b5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibuavcan_1_1time_1_1_monotonic.html">libuavcan::time::Monotonic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#add5d3279f4c8cf64eaf0b6a9a704b5b7">timestamp</a></td></tr>
<tr class="separator:add5d3279f4c8cf64eaf0b6a9a704b5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7c8e1d58a2410c052c3132c1d04187a3"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a7c8e1d58a2410c052c3132c1d04187a3">MaskExtID</a> = 0x1FFFFFFFU</td></tr>
<tr class="separator:a7c8e1d58a2410c052c3132c1d04187a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96501555af3248ad009c6c4172c99e21"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a96501555af3248ad009c6c4172c99e21">MaskIdWithFlags</a></td></tr>
<tr class="separator:a96501555af3248ad009c6c4172c99e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d70a3d96531d233c507a74f0a60759d"><td class="memItemLeft" align="right" valign="top">static constexpr std::uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a5d70a3d96531d233c507a74f0a60759d">MTUBytes</a> = MTUBytesParam</td></tr>
<tr class="separator:a5d70a3d96531d233c507a74f0a60759d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt;<br />
struct libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;</h3>

<p>A raw <a class="el" href="namespace_c_a_n.html">CAN</a> frame, as passed to/from a <a class="el" href="namespace_c_a_n.html">CAN</a> peripheral or subsystem. This is the datastructure used by the media layer of libuavcan to buffer incoming data that is "interesting" before the transport layer parses it into the high-level types defined by DSDL. Interesting data is defined as <a class="el" href="namespace_c_a_n.html">CAN</a> frames that are compatible with the UAVCAN protocol. For <a class="el" href="namespace_c_a_n.html">CAN</a> bus, this omits error frames, remote frames, and any frame using 11-bit identifiers. Such uninteresting frames are not compatible with UAVCAN and it is undefined behaviour to attempt to load such data into a <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> instance.</p>
<p>For systems which consume unsupported <a class="el" href="namespace_c_a_n.html">CAN</a> frames it is recommended that another data path is established that does not involve libuavcan. For example, a "statistics" interface might be supported by a driver on a system to handle bus error rate at an application level.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MTUBytesParam</td><td>The maximum number of bytes that can be stored in this frame. </td></tr>
    <tr><td class="paramname">FlagBitsCompareMask</td><td>A mask of the upper thee bits of this class's id field. By default these bits are ignored by equality operators in the class. If an implemenation wants to use these three bits as meta-data it should provide a different compare mask to include the bits when comparing identifiers.</td></tr>
  </table>
  </dd>
</dl>
<h4>Data Domains and Filtering</h4>
<p>Libuavcan will introduce two copies of data received on a <a class="el" href="namespace_c_a_n.html">CAN</a> bus into and then across system memory before this data becomes available to an application. Because of this the media layer should be implemented as close to the incoming data as possible. For embedded systems it is ideal if a <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> is the first location in system memory the received data occupies after being read out of peripheral memory. For higher-level systems it is ideal if a <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> is the first location in user-space the data occupies after being received from a kernel.</p>
<div class="image">
<img src="data_domains.png" alt="data_domains.png" width="100%"/>
</div>
 <p>As demonstrated by the above diagram, careful configuration of hardware filters and proper elision of unsupported data will minimize the amount of CPU used by libuavcan to copy data through system memory. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8ba1832b4f51d0baf43924c5629d635a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba1832b4f51d0baf43924c5629d635a">&#9670;&nbsp;</a></span>Frame() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::<a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor for frames.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The frame to copy from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2358b525d70f979b3f1adc9f2646ae1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2358b525d70f979b3f1adc9f2646ae1e">&#9670;&nbsp;</a></span>Frame() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::<a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>can_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint8_t *&#160;</td>
          <td class="paramname"><em>can_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a>&#160;</td>
          <td class="paramname"><em>in_dlc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibuavcan_1_1time_1_1_monotonic.html">libuavcan::time::Monotonic</a>&#160;</td>
          <td class="paramname"><em>can_timestamp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> object with timestamp that copies data into this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can_id</td><td>The 29-bit <a class="el" href="namespace_c_a_n.html">CAN</a> id. </td></tr>
    <tr><td class="paramname">can_data</td><td>The data to copy into this instance. </td></tr>
    <tr><td class="paramname">in_dlc</td><td>The data length code for the can_data. </td></tr>
    <tr><td class="paramname">can_timestamp</td><td>A monotonic timestamp that should be as close to the time the start-of-frame was received (for rx frames) or put-on-bus (for tx frames) as possible. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a935f666c376898fee73c0732bd9ca08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935f666c376898fee73c0732bd9ca08c">&#9670;&nbsp;</a></span>Frame() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::<a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>can_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::uint8_t *&#160;</td>
          <td class="paramname"><em>can_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a>&#160;</td>
          <td class="paramname"><em>in_dlc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a new <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> object that copies data into this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">can_id</td><td>The 29-bit <a class="el" href="namespace_c_a_n.html">CAN</a> id. </td></tr>
    <tr><td class="paramname">can_data</td><td>The data to copy into this instance. </td></tr>
    <tr><td class="paramname">in_dlc</td><td>The data length code for the can_data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf1613d2807c86ec495b30851a4eb429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf1613d2807c86ec495b30851a4eb429">&#9670;&nbsp;</a></span>dlcToLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::uint_fast8_t <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::dlcToLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a>&#160;</td>
          <td class="paramname"><em>dlc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a Data Length Code into a frame length.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlc</td><td>The DLC to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of bytes the frame can occupy for the given DLC. </dd></dl>
<p>Lookup table to map a DLC value to the maximum data payload length supported for the DLC.</p>

</div>
</div>
<a id="afd1bb5849b58b8510d05a3d0756db392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd1bb5849b58b8510d05a3d0756db392">&#9670;&nbsp;</a></span>getDataLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::uint_fast8_t <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::getDataLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get length of the frame data in bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>std::uint_fast8_t The number of bytes this <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> object contains. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classlibuavcan_1_1example_1_1_socket_c_a_n_interface.html#a487a0e2be2f9b15575b0f0d7a74d444f">libuavcan::example::SocketCANInterface::write()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_afd1bb5849b58b8510d05a3d0756db392_icgraph.png" border="0" usemap="#structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_afd1bb5849b58b8510d05a3d0756db392_icgraph" alt=""/></div>
<map name="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_afd1bb5849b58b8510d05a3d0756db392_icgraph" id="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_afd1bb5849b58b8510d05a3d0756db392_icgraph">
<area shape="rect" id="node2" href="classlibuavcan_1_1example_1_1_socket_c_a_n_interface.html#a487a0e2be2f9b15575b0f0d7a74d444f" title="libuavcan::example\l::SocketCANInterface\l::write" alt="" coords="228,5,388,61"/>
</map>
</div>

</div>
</div>
<a id="ad5eade23c4b714ada7510a1170f73261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5eade23c4b714ada7510a1170f73261">&#9670;&nbsp;</a></span>getDLC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a> <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::getDLC </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the Data Length Code set for this instance.</p>
<dl class="section return"><dt>Returns</dt><dd>The DLC set for this instance. </dd></dl>

<p class="reference">Referenced by <a class="el" href="classlibuavcan_1_1example_1_1_socket_c_a_n_interface.html#a487a0e2be2f9b15575b0f0d7a74d444f">libuavcan::example::SocketCANInterface::write()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_ad5eade23c4b714ada7510a1170f73261_icgraph.png" border="0" usemap="#structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_ad5eade23c4b714ada7510a1170f73261_icgraph" alt=""/></div>
<map name="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_ad5eade23c4b714ada7510a1170f73261_icgraph" id="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_ad5eade23c4b714ada7510a1170f73261_icgraph">
<area shape="rect" id="node2" href="classlibuavcan_1_1example_1_1_socket_c_a_n_interface.html#a487a0e2be2f9b15575b0f0d7a74d444f" title="libuavcan::example\l::SocketCANInterface\l::write" alt="" coords="224,5,384,61"/>
</map>
</div>

</div>
</div>
<a id="a719c9c9fbb3c473108cfc7fa12c6c856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719c9c9fbb3c473108cfc7fa12c6c856">&#9670;&nbsp;</a></span>lengthToDlc()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="can_8hpp.html#a0ad1b9afc0a21a51edf6cc41df1bf96e">FrameDLC</a> <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::lengthToDlc </td>
          <td>(</td>
          <td class="paramtype">std::uint_fast8_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a given frame length value into a Data Length Code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>The data length value to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the appropriate DLC value but saturates to the DLC for the MTUBytesParam parameter. </dd></dl>
<p>Lookup table to map a <a class="el" href="namespace_c_a_n.html">CAN</a> frame length to a DLC value that will accommodate the frame.</p>

</div>
</div>
<a id="a695aff92f84e1e513deae2d7c0d6cfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695aff92f84e1e513deae2d7c0d6cfb2">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::<a class="el" href="namespacelibuavcan.html#ad3a35be7eefd543600cd6fff94151dec">operator!</a>= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Logical inverse of <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a923a7e4e9cc03d737dd71258928e6cfb">libuavcan::media::CAN::Frame::operator==</a>(const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&amp;) const</p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a923a7e4e9cc03d737dd71258928e6cfb">libuavcan::media::CAN::Frame::operator==</a>(const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&amp;) const returns false. </dd></dl>

</div>
</div>
<a id="a53a9aa982a961cea7e930d74f8a69a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a9aa982a961cea7e930d74f8a69a85">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="namespace_c_a_n.html">CAN</a> <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> comparisons compare the priority of the frames not the values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a7f1ae0b9d24e022c4d942f874f92cbc7">Frame::priorityHigherThan</a> for more details on <a class="el" href="namespace_c_a_n.html">CAN</a> bus arbitration. </dd></dl>

</div>
</div>
<a id="aabce585db499eb1d688e3052b86b5530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabce585db499eb1d688e3052b86b5530">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>&amp; <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. This will copy all the data from rhs into this instance.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>The frame to copy data from. </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">References <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a9cf6cc91db672202e497c7de8a3bda07">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::data</a>, <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a81731e84998bac95bd01ccc5ea06d3f8">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::id</a>, and <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#add5d3279f4c8cf64eaf0b6a9a704b5b7">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::timestamp</a>.</p>

</div>
</div>
<a id="a923a7e4e9cc03d737dd71258928e6cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923a7e4e9cc03d737dd71258928e6cfb">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares equality for the <a class="el" href="namespace_c_a_n.html">CAN</a> <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> identifier, DLC (Data Length Code), and data.</p>
<dl class="section return"><dt>Returns</dt><dd>true if both identifiers masked by MaskIdWithFlags are equal, both DLCs are equal, and the data in both frames are equal. </dd></dl>

<p class="reference">References <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a9cf6cc91db672202e497c7de8a3bda07">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::data</a>, and <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a81731e84998bac95bd01ccc5ea06d3f8">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::id</a>.</p>

</div>
</div>
<a id="af9d956ffede16256c9f584f46f137bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9d956ffede16256c9f584f46f137bce">&#9670;&nbsp;</a></span>operator>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="namespace_c_a_n.html">CAN</a> <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> comparisons compare the priority of the frames not the values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a7f1ae0b9d24e022c4d942f874f92cbc7">Frame::priorityHigherThan</a> for more details on <a class="el" href="namespace_c_a_n.html">CAN</a> bus arbitration. </dd></dl>

</div>
</div>
<a id="a7f1ae0b9d24e022c4d942f874f92cbc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1ae0b9d24e022c4d942f874f92cbc7">&#9670;&nbsp;</a></span>priorityHigherThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::priorityHigherThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple comparison of <a class="el" href="namespace_c_a_n.html">CAN</a> identifiers. Since it is illegal to populate a <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a> with any message type not supported by UAVCAN (e.g. error frames or frames with 11-bit identifiers) this method does a trivial comparison between two can identifiers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>A frame to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the rhs identifier is &lt; this frame's id.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>See Marco Di Natale - <a href="http://inst.cs.berkeley.edu/~ee249/fa08/Lectures/handout_canbus2.pdf">"Understanding and using the Controller Area Network"</a> for information on how <a class="el" href="namespace_c_a_n.html">CAN</a> message identifiers are used in <a class="el" href="namespace_c_a_n.html">CAN</a> arbitration. </dd></dl>

<p class="reference">References <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a81731e84998bac95bd01ccc5ea06d3f8">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::id</a>.</p>

<p class="reference">Referenced by <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a2fa7dcd1768a8494c085f70009c234f4">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::priorityLowerThan()</a>.</p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_a7f1ae0b9d24e022c4d942f874f92cbc7_icgraph.png" border="0" usemap="#structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_a7f1ae0b9d24e022c4d942f874f92cbc7_icgraph" alt=""/></div>
<map name="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_a7f1ae0b9d24e022c4d942f874f92cbc7_icgraph" id="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame_a7f1ae0b9d24e022c4d942f874f92cbc7_icgraph">
<area shape="rect" id="node2" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a2fa7dcd1768a8494c085f70009c234f4" title="libuavcan::media::CAN\l::Frame::priorityLowerThan" alt="" coords="253,5,449,47"/>
</map>
</div>

</div>
</div>
<a id="a2fa7dcd1768a8494c085f70009c234f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa7dcd1768a8494c085f70009c234f4">&#9670;&nbsp;</a></span>priorityLowerThan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::priorityLowerThan </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple comparison of <a class="el" href="namespace_c_a_n.html">CAN</a> identifiers. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a7f1ae0b9d24e022c4d942f874f92cbc7">Frame::priorityHigherThan</a> for more details.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>A frame to compare with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the rhs identifier is &gt; this frame's id. </dd></dl>

<p class="reference">References <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a7f1ae0b9d24e022c4d942f874f92cbc7">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::priorityHigherThan()</a>.</p>

</div>
</div>
<a id="a6a80e74e1b1dd8d6d1877dd7b09ac59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a80e74e1b1dd8d6d1877dd7b09ac59a">&#9670;&nbsp;</a></span>setDataLength()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::setDataLength </td>
          <td>(</td>
          <td class="paramtype">std::uint_fast8_t&#160;</td>
          <td class="paramname"><em>data_length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the Data Length for this <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">Frame</a>. This value can be quantized for some lengths as only the Data Length Code is stored internally. So setDataLength(some_value) may not be equal to <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#afd1bb5849b58b8510d05a3d0756db392">getDataLength()</a>. after it is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_length</td><td>The data length in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a9cf6cc91db672202e497c7de8a3bda07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf6cc91db672202e497c7de8a3bda07">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint8_t <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::data[MTUBytesParam]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>System memory buffer of a <a class="el" href="namespace_c_a_n.html">CAN</a> frame. </p>

<p class="reference">Referenced by <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#aabce585db499eb1d688e3052b86b5530">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::operator=()</a>, <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a923a7e4e9cc03d737dd71258928e6cfb">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::operator==()</a>, and <a class="el" href="classlibuavcan_1_1example_1_1_socket_c_a_n_interface.html#a487a0e2be2f9b15575b0f0d7a74d444f">libuavcan::example::SocketCANInterface::write()</a>.</p>

</div>
</div>
<a id="a81731e84998bac95bd01ccc5ea06d3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81731e84998bac95bd01ccc5ea06d3f8">&#9670;&nbsp;</a></span>id</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::uint32_t <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::id</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The 29-bit <a class="el" href="namespace_c_a_n.html">CAN</a> identifier. The upper three bits is ignored by default but applications can use these bits either opaquely or by enabling in frame comparisons them using the <code>FlagBitsCompareMask</code> template parameter.</p>
<div class="fragment"><div class="line"><span class="comment">// Enable comparison of the 30th bit in the identifier.</span></div><div class="line">CAN::Frame&lt;CAN::TypeFD::MaxFrameSizeBytes,0x01&gt; frame;</div><div class="line"></div><div class="line"><span class="comment">// Use the 30th bit.</span></div><div class="line">frame.id = (can_id | (MY_FLAG &lt;&lt; 29);</div></div><!-- fragment --> 
<p class="reference">Referenced by <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#aabce585db499eb1d688e3052b86b5530">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::operator=()</a>, <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a923a7e4e9cc03d737dd71258928e6cfb">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::operator==()</a>, <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a7f1ae0b9d24e022c4d942f874f92cbc7">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::priorityHigherThan()</a>, and <a class="el" href="classlibuavcan_1_1example_1_1_socket_c_a_n_interface.html#a487a0e2be2f9b15575b0f0d7a74d444f">libuavcan::example::SocketCANInterface::write()</a>.</p>

</div>
</div>
<a id="a7c8e1d58a2410c052c3132c1d04187a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8e1d58a2410c052c3132c1d04187a3">&#9670;&nbsp;</a></span>MaskExtID</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::MaskExtID = 0x1FFFFFFFU</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>29-bit mask for extended frame identifiers. </p>

</div>
</div>
<a id="a96501555af3248ad009c6c4172c99e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96501555af3248ad009c6c4172c99e21">&#9670;&nbsp;</a></span>MaskIdWithFlags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint32_t <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::MaskIdWithFlags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">        <a class="code" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a7c8e1d58a2410c052c3132c1d04187a3">MaskExtID</a> | (<span class="keyword">static_cast&lt;</span>std::uint32_t<span class="keyword">&gt;</span>(FlagBitsCompareMask) &lt;&lt; 29)</div></div><!-- fragment --><p>The mask to use when comparing two <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#a81731e84998bac95bd01ccc5ea06d3f8">Frame::id</a> fields. </p>

</div>
</div>
<a id="a5d70a3d96531d233c507a74f0a60759d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d70a3d96531d233c507a74f0a60759d">&#9670;&nbsp;</a></span>MTUBytes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::uint16_t <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::MTUBytes = MTUBytesParam</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The maximum number of bytes this frame can hold. This value also effects the largest DLC the instance will report and the largest DLC the instance will accept. </p>

</div>
</div>
<a id="add5d3279f4c8cf64eaf0b6a9a704b5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5d3279f4c8cf64eaf0b6a9a704b5b7">&#9670;&nbsp;</a></span>timestamp</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::uint16_t MTUBytesParam, std::uint8_t FlagBitsCompareMask = 0x00&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibuavcan_1_1time_1_1_monotonic.html">libuavcan::time::Monotonic</a> <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html">libuavcan::media::CAN::Frame</a>&lt; MTUBytesParam, FlagBitsCompareMask &gt;::timestamp</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A monotonic timestamp. Libuavcan operates optimally when this value is a hardware supplied timestamp recorded at the start-of-frame. </p>

<p class="reference">Referenced by <a class="el" href="structlibuavcan_1_1media_1_1_c_a_n_1_1_frame.html#aabce585db499eb1d688e3052b86b5530">libuavcan::media::CAN::Frame&lt; MTUBytesParam, FlagBitsCompareMask &gt;::operator=()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/repo/libuavcan/include/libuavcan/media/<a class="el" href="can_8hpp_source.html">can.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
</div>
</div>
</div>
</div>
</div>
<address class="footer-copyright"><small>
  <a href="https://uavcan.org">UAVCAN</a>
   Copyright (C) 2014-1029 Pavel Kirienko <pavel.kirienko@gmail.com>
   Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved
   This documentation is provided under the MIT licence as part of the <a href="https://github.com/UAVCAN/libuavcan/blob/master/LICENSE">libuavcan project</a>.
  </small></address>
</body>
        <script type="text/javascript" src="doxy-boot.js"></script>
</html>
